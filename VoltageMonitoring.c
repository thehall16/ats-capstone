// Voltage Monitoring 
// MCU: STM32C031K6T6
// Sensor: ZMPT101B
// Author: Spencer Grow

#include <stdio.h>
#include <math.h>
//#include "main.h"
#include "generator.h"

//global vars
ADC_HandleTypeDef hadc1;     // Handle for the ADC hardware (ADC1)
float voltage_rms = 0.0f;    // Stores last measured RMS voltage (in volts)
float mains_threshold = 80.0f; // Voltage threshold (below this = power failure)

//Pin assignments for SSR
GPIO_TypeDef* SSR_PORT = GPIOA;
uint16_t MAIN_SSR_PIN   = GPIO_PIN_1;
uint16_t BACKUP_SSR_PIN = GPIO_PIN_2;

//Function Prototypes
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_ADC1_Init(void);
float Read_Voltage_RMS(void);

//main
int main(void){

    HAL_Init(); //initalize HAL
    SystemClock_Config();     // Configure system clock (auto-generated by CubeIDE)
    MX_GPIO_Init();           // Initialize GPIO pins (for SSR control)
    MX_ADC1_Init();           // Initialize ADC1 (for voltage sensor)

    while (1)
    {
        // Step 1: Measure AC RMS voltage from ZMPT101B
        voltage_rms = Read_Voltage_RMS();

        // Step 2: Compare voltage to threshold to decide power state
        if (voltage_rms < mains_threshold)
        {
            //Power failure detected
            HAL_GPIO_WritePin(SSR_PORT, MAIN_SSR_PIN, GPIO_PIN_RESET); // Turn OFF main SSR

            // Step 3: Run generator startup simulation
            generator_startup_sequence();  // This runs choke -> start -> run

            // Step 4: Turn ON backup SSR only after generator is "ready"
            HAL_GPIO_WritePin(SSR_PORT, BACKUP_SSR_PIN, GPIO_PIN_SET);
        }
        else
        {
            // Main power normal

            HAL_GPIO_WritePin(SSR_PORT, MAIN_SSR_PIN, GPIO_PIN_SET);   // Turn ON main SSR
            HAL_GPIO_WritePin(SSR_PORT, BACKUP_SSR_PIN, GPIO_PIN_RESET); // Turn OFF backup SSR

            // Stop generator simulation
            generator_stop();
        }

        HAL_Delay(500); // Wait 0.5s before checking again
    }
}

// RMS Voltage Reading
float Read_Voltage_RMS(void)
{
    const uint16_t samples = 200;    // Number of ADC samples per cycle
    uint32_t sum_sq = 0;
    uint16_t adc_val = 0;

    for (uint16_t i = 0; i < samples; i++)
    {
        HAL_ADC_Start(&hadc1);
        HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
        adc_val = HAL_ADC_GetValue(&hadc1);
        HAL_ADC_Stop(&hadc1);

        sum_sq += adc_val * adc_val;
    }

    // Compute RMS of ADC values
    float adc_rms = sqrtf((float)sum_sq / samples);

    // Convert ADC reading to voltage
    // Assuming 3.3V reference and 12-bit ADC (0â€“4095)
    float sensor_voltage = (adc_rms / 4095.0f) * 3.3f;

    // Convert to AC RMS (calibration factor depends on ZMPT101B gain)
    float voltage_rms = sensor_voltage * 100.0f;  // Example calibration factor

    return voltage_rms;
}


//Peripheral init

//GPIO_init for SSRs 

//ADC_init for voltage monitoring

